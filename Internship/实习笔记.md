# 实习笔记

## 3

9月9日

工作内容：Vue2.0的学习

本周的任务安排包括学习Vuejs的相关知识，细化可以分成路由守护、Vuex的页面间状态交换机，API的调用的熟悉等。

在理论阶段，我了解到了调用API的工具axios，并在实现登出功能时使用了所需要的API。实践阶段，我通过使用catch语句解决了由于路由调用错误而出现的NaviagationDuplication问题，这个解决方法是来自github上的别人提出的关于路由钩子的相关问题。

不仅如此，由于包含登录功能的前端系统通常会用到存储的Cookies，需要通过vuex辅助Cookies实现不同路径下页面内的带权限限制的访问功能。基于此点了解了关于Expires等属性相关的赋值以及意义。

由于需要模仿实现的系统中包含多种功能与子功能的页面，后记还挑选了其中一部分具有代表性的内容进行着重地练习。主要包括登录，一览，人员情况分类等等。其中给我留下较深印象的是尝试进行Account总体数据的显示页面的实现过程。

## 4

9月13日

工作内容：Vue2.0的学习

对本周的工作内容进行总结。在上一周的练习项目的基础上，继续运用了vue-validator，组件之间数据传递的其他方法，element-ui的CSS框架，对原型对象挂载全局函数等技术点。

接下来对各个技术点在实践时遇到的问题

在使用vue-validator进行表单提交项时，需要使用Vue原型的$refs属性对需要检查的form进行注册（也叫挂载），才能够使用validator的检测库来检验其数据是否符合编程者规定的正则约束。

在使用Vue框架进行前端的实现时，组件之间的数据传递可以简单分为以下几种方式：1. 使用路由的变量进行数据传递。这种形式传递的数据会直接显示在路由里。 2. 使用挂载在Vue原型上的vuex库，他能够以规定的流程接收某个组件内的数据并储存，等待其他页面对其中存储的数据进行访问。 3. 将单独的一个Vue作为Bus（总线）挂载在原型Vue上，使原型Vue下的所有组件页面都能够对该Bus内的数据读写。

## 5

9月16日

工作内容：微信小程序

本周开始了手机上的小程序的设计，主要学习到的知识点如下：

element-ui，主要了解了TimePicker等各种时间日期选择器的用法，生成几个固定的时间点，以便用户快速选择。

在Vue原型上挂载对JS的Date对象原型添加的该应用下的页面全局都可使用的函数，主要利用了export default install(Vue, options)这种形式实现。

不仅如此，还遇到了一些页面上的问题。比如，不知道是因为框架还是什么其他的原因，点击单个item没办法直接切换整个元素的选中。

除此之外，还对设计的该小程序进行了界面和功能点上的优化。心得如下：

CSS方面：使用的图片如果是本地文件，而需要用到vue的动态绑定功能来动态地显示图片，就需要在:src的基础上，将本地图片的地址用require进行引用。在单选框的样式需要更改的情况下，需要用background-size: cover，并使用:class实现选择按钮的样式切换。

由于暂时不知道部署后的完整URL是什么，所以暂时不知道的是如何获取taxCode的地址。

## 6

9月20

工作内容：微信小程序

在前日的基础上，继续对JS进行了优化，包括但不限于以下内容：

利用先前学习的将函数挂载在vue原型上的方法，将每个组件中包含的时间格式的函数放到了全局函数的文件里（exports.install = ...）

顺应需求的变化，在成功完成事务后直接跳转至新页面（window.location.href = url）

就前一篇记录中提到的不知道完整的部署url问题，已经得到解决。最后的解决方法是通过url来获取查询页面公司的taxCode的。（let e = /(?=taxCode=)(\d+), let taxCode = e.exec(url)[1]）

至于CSS的优化，更改了一些图片、单选框的样式，颜色的统一问题，调整了消息框的样式。如果遇到CSS的优先顺序的问题，可以将需要覆盖其他样式的语句写上!important，但在项目的规模较大时，最好避免使用这条语句，以免造成进一步的覆盖。

等到项目接近完成时，遇到了静态图片以及element-ui的相关icon打包失效的问题。最后查询了网页，发现是webpack的打包参数配置中，需要将有效的路径调整为相对路径的'./'，再添加一行 publicPath: '../../'或者是在webpack.base.conf.js中添加resolve(path.join(__dirname, '..', dir))的函数。

## 7

9月23

工作内容：Vue2.0学习的收尾

由于先前的小程序项目用到了根据用户滑动屏幕的动作进行列表数据的加载的功能，而且滑动事件发生的时候，页面的当前滑动高度scrollHeight通常会频繁地变化，所以需要用到防抖和节流的相关处理方法。其中，防抖指触发事件后在规定时间内回调函数只能执行一次，如果在规定时间内又触发了该事件，则会重新开始算规定时间；而节流是指通过定时器将回调函数进行延时。如果在规定时间内继续回调，发现存在之前的定时器，则将该定时器清除，并重新设置定时器。这里有个细节，就是后面所有的回调函数都要能访问到之前设置的定时器，这时就需要用到闭包。为了全局调用的方便，还将它加入到了Vue的全局函数库中。

除此之外，值得一提的是使用了LESS语言编写Vue组件的内部样式。这种预处理语言能够以变量，函数的概念来编写CSS样式，使存在包含关系的DOM节点的样式属性能够更加方便地只在作用域内生效。

## 8

9月27

工作内容：Django的学习

在通过前辈写的练习项目以及微信小程序的锻炼下，初步地学习并实践了使用Vue2.0进行前端开发的过程，见识了一些应用过程中可能出现的问题以及了解掌握了对应的解决方法。

但Vue2.0毕竟是开始实习之前就已经掌握了部分应用方法的一种技术，在此基础上，还是希望能够充分利用前来公司实习的时间，不仅能够将所学运用到实践中，也了解与前端相关的更多流行技术，于是我选择了接下来进行Python语言下的Django网页开发框架的学习。

选择Django的一方面是因为我对Python语言比较熟悉，了解它的基础语法和一部分常用库函数；另一方面则是因为Python在目前的行业领域内的知名度和流行程度比较高，发展的空间也被大多数人看好，很多既有的算法开发也会考虑Python作为开发语言。于是在接下来的一段时间内，我会参考Django的官方网站上的示例应用开发教程，在同时结合经验与使用网络资源补充知识的方法下，开展对Django的使用方法的相关学习任务。

## 9

9月30

工作内容：完成Django在服务器端的应用方法

虽然Django也包含类似于Vue2.0的页面组件的视图内容，但比起Vue，Django的不同点在于一个网页应用的前端到后端都能够用它来完成，基于的就是它的业务层中的模型层、模板层。

由于网页一般需要基于表单，输入框来接受或是固定类型或是不固定类型（取决于使用的数据库是否是面向关系型的）的数据，并将它们储存于数据库之中，Django的模型层就是用来定义数据被存储到数据库列中所对应的类型的。主要通过Model Class来进行类型的定义，定义后通常还会使用Migration将由代码定义的数据库表“同步”到真正的数据库中。在这一层，也会用到QuerySets等方法进行数据的查询。

如果需要对数据库的数据进行处理，比较推荐的执行方法通常是建立一个模型实例管理对象，并在模型实例中创建调用模型对象中包含的方法。这样能够一定程度上对模型对象的管理进行自定义，而且能够保证原对象方法不受到个别程序开发需要的影响。

## 10

10月4 划掉 10月8

工作内容：Django框架在网页前端的应用方法

同Vue只能作为前端应用开发的框架，在跨域这个行为方面来说不一样的是，Django的服务器程序可以和页面提供代码同时使用dispatcher将使用了某个指定的template的视图挂载到指定路由下，也就是说网页中看到的视图实际上是直接由服务器在接收到HTTP请求后传递过来的HTML数据，所以由于不存在域名/IP、端口方面的差别，会比需要借助axios等工具发送后端请求而言更加便捷。

而和Vue相同的则是作为更为丰富的视图样式的定义解决方法存在的Templates。此类模板通常通过get_template受到调用，接收一定格式的数据，并经过Django的渲染函数将数据渲染至模板内规定的数据表示位置。

此外，在建立网页应用的显示部分的内容时，发现先前进行Model的数据查询方法的定义的一点差异：Model.objects.get()以及Model.object.filter()之间存在的区别是返回数据的类型，前者是question，后者则是questionSet。

## 11

10月11

工作内容：Vue3.0的预了解与公司组织的电影会

Vue3.0的核心机制是称为Function-based API。与2.0中的单页面内包含的函数等内容都是以对象包裹不同的是，核心的内容都将以函数的形式被提供。这一改动能够让原先的mixin模式带来的比如模板中的数据来源不清晰、命名空间重复等问题得到一定程度上的解决。

实现这一改动的原理是Vue3.0使用了Proxy来代替原先的Object.defineproperty来实现互动对象的数据响应问题。通过劫持get和set这两个大部分的数据类型都有的数据值修改和读取行为，能够将页面从原来的mixin模式下解放出来，最后达到减少原本额外的组件实例嵌套封装造成的额外开销的目的。

而早上进行了上述内容的学习之后，下午就随着同事们一起骑车前往了公司附近的影院准备去看《我和我的祖国》。由于我是实习生的缘故，并没有公司里大家都有的短袖工装，于是我就换上了同事姐姐临时发给我的短袖工装，在电影放映厅的外面和大家一起拿着国旗拍了照。这次与大家一起行动的集体活动还是很让人印象深刻的。

## 12

10月14

工作内容：了解使用Vue3.0实现v-model的方法

值得一提的是，在Vue3.0中， 已经不再支持 v-model 了，而使用 .sync 来代替，但是仍然能够利用 vue 的双向绑定实现 vue2.x 中的v-model功能。

Vue2.0中，框架的工作逻辑是首先获取模板的v-model属性，并获取绑定到的属性。此后，当数据发生变化时， 更新视图（这里会在trigger进行触发），当视图改变数据时修改数据。下面是数据变化响应对象的创建和视图更新的响应方法：

昨天知道了Proxy能够返回一个已经代理的对象，，那么只要对一个对象设置一个包含get和set动作的处理方法的代理，就能在这两个行为被触发时进行数据处理了。为了让包含多层嵌套的对象的内部数据修改都能够被捕捉到，也可以在处理方法里写一个按深度迭代的逻辑，这里不做赘述。

在模板编译的过程中，只要获取到某个元素标签中存在v-model属性，就对它添加一个watcher，内容是监听某个元素的改变事件，并返回上面的响应对象。

这样就能够做到在V3.0中继续使用v-model属性进行数据的监听了。

## 13

10月18

工作内容：Vue3.0 TS

在Vue2.0广泛的到应用的同时，开发组早在去年就开始了Vue3.0的筹备计划。在了解到3.0放出了先览内容的reactive对象之后，我通过搜索引擎了解到了在这次版本更新中作为基地的TypeScript的作用。它能够在JavaScript的语法基础上，为函数或者变量提供类型方面的约束或是进行接口扩展的一系列操作。

我还了解到，在此基础上， 组件 API 设计所面对的核心问题之一就是如何组织逻辑，以及如何在多个组件之间抽取和复用逻辑。  Function-based API 受 React Hooks 的启发，提供了一个全新的逻辑复用方案，且不存在上述问题。  使用基于函数的 API，开发者将与组件相关联的代码抽取到一个 "composition function" 中，也就是做到了将逻辑进行封装， 并将需要暴露给组件的状态以响应式的数据源的方式返回出来 。这样写出的组件既能够清晰地知道模板中的属性的来源（从函数返回），返回值也可以被任意重命名。

## 14

10月21

工作内容：学习LaTex的相关知识

除了项目方面，个人觉得也应该熟悉各种其他可能会用到的技术。举例而言，LaTex语言是一种建立在TeX上的免费文档处理系统，后者是一种用于排版开发的语言，但是在稍作了解后发现比较难以学习与使用，而且在进行文档撰写时也用不到其中很多的内容，于是选择学习扩展了TeX中的文档创建相关内容的LaTeX。

根据不同的电脑操作系统，可能会有已经安装好了TeX的电脑，但Windows下首先需要完成的工作就是安装。在此之前，我了解到MD语言的编译器能够支持LaTeX的语法显示，于是找到了在线的MD编辑器作为学习LaTeX的平台。

就结果而言，平常用到的比较多的一般是普通的数学符号，简单的单行公式的上下标记。如果涉及到需要用到复数行的公式的话，就要学习有关多行公式的内容了。有关内容准备等到日后需要用的时候再进行查阅。

## 15

10月25

工作内容：了解Vue3.0的性能提高原理和新性能的利弊

前段时间已经知道，在Vue3.0中用到Proxy代替原先的数据行为跟踪。在此次更新中， 整个数据监听系统都进行了重构，由es5的Object.defineProperty改为了es6的proxy 。Vue的创始人说这个新的数据监听系统带来了初始化速度加倍同时内存占用减半的效果，主要因为以前的Vue2.0使用的Object.defineProperty存在两点问题：需要遍历所有的属性，如果对象的data或computed或props中的数据项内容多，遍历起来的速度就会变慢，用于监听的内存开销也会变大。

而在JS的语法更新到ES6之后，在Vue3.0利用了Proxy之后，不仅解决了上面所说的内存问题，新添加的数据类型Set、 WeakSet、Map、WeakMap的变化也能够受到监听、同时可以监听Class、属性的新建和删除以及数组元素的增加和删除。而Vue3.0唯一的缺点就是在检测到如果是使用IE的情况下会自动降级为Object.defineProperty的数据监听系统，享受不到速度加倍，内存减半的体验。

## 16

10月28

学习内容：利用Redis实现“附近的人”功能

从网络上的一篇文章上了解到针对“附近的人”这一位置服务领域的应用场景，常见的可使用PG、MySQL和MongoDB等多种DB的空间索引进行实现。而Redis另辟蹊径，结合其有序队列zset以及geohash编码，实现了空间搜索功能，且拥有极高的运行效率。

要提供完整的“附近的人”服务，最基本的是要实现“增”、“删”、“查”的功能。自Redis 3.2开始，Redis基于geohash和有序集合提供了地理位置相关功能。 Redis Geo模块包含了以查为核心的六个命令，可以很快地返回给定位置对象为中心的不超过给定最大距离的所有位置对象。

具体实现通过组合使用GEOADD和GEORADIUS可实现“附近的人”中“增”和“查”的基本功能。直接使用GEORADIUSBYMEMBER命令实现微信中“附近的人”功能。其中“给定的位置对象”即为用户本人，搜索的对象为其他用户。不过本质上，GEORADIUSBYMEMBER = GEOPOS + GEORADIUS，即先查找用户位置再通过该位置搜索附近满足位置相互距离条件的其他用户对象。

## 17

11月1

工作内容：票据查询微信小程序

上一次的票据小程序交给我之前，没有让我参加开发组的会议，且没有UI设计师参与，而是组长直接交给我经由原型设计的界面稿。而在这次，组长让我也参与了和产品、UI设计以及测试的人们一起参加的协作会议。

在会议上，原型首先给大家展示了总结了客户需求之后发布的第一期原型稿。在演示期间。我们都认真听取了原型的设计内容并作了一定笔记。演示过后，大家都就刚才听到的内容提出自己的疑问，部分地方也就一些存疑内容进行了协商和妥协。最后，其中的一部分原型设计内容得到了大家都觉得比较合理的修改，会议就结束了。

在这次会议里，我体会到了项目组人员进行沟通的必要性。因为只有在大家经过讨论，修改了原型的不合理之处后，才有可能将一些后期难以修改的错误在早期就改正过来。不仅如此，这样的会议也有助于让所有人对最后的产品有一个全景图，能够以全局出发进行个人的设计。

## 18

11月4

工作内容：进行微信小程序的开发

虽然在工作刚刚开始的时候就已经参与了会议，并解决了一部分原型设计中隐含的问题，但是在这之后，仍然还是遇到了需求与实际开发内容存在较大误差的情况。

由于实际作为前端开发，能够参照的文档就是原型文档、UI的设计文档以及后端的API说明文档，所以如果是这两个文档之中没有详细说明的需求，或是某个功能的实现细节，作为前端的开发只能在个人的能力或者理解范围之内进行优化和调整。如果以后还会进行开发工作，个人感觉比较必要的是拿到一份客户需求的详细说明文档，这样就能够在兼顾多方设计的情况下给出一个较好的前端解决方案。

最后，虽然就个人测试结果，修改了的内容也有很多，但是还是需要将项目交给测试的同事，等待他们的后续反馈，再对目前开发的项目进行修改。

## 19

11月8

工作内容：微信小程序的优化

和之前的项目相比，此次的项目确实在人员组织上十分正规。不仅有之前所说的UI设计参与，而且测试的同事也会在禅道这样的项目管理页面上进行错误的提交和反馈。

以前有人说JavaScript是一种比较混乱的语言，虽然随着网页的普及，语言本身已经得到很大程度的优化了，但很多时候仍然会发生让开发者觉得匪夷所思的问题，所以JS这一部分才会被认为是很多公司面试里的重难点吧。这次进行开发的时候，测试也提出了一些类似的问题。

除此之外，由于是微信小程序，需要在各种不同的型号的手机上进行测试，确保各种平台的使用用户的体验是一致的。所以在页面上的调整内容大部分都是与平台不兼容相关的。开发时的流程就是写页面→测试→根据设备调整页面兼容→根据UI设计稿调整总体效果。

## 20

11月11

工作内容：微信小程序的收尾

在项目交付的前日，各个岗位的大家仍然在就自己的工作范围内的任务进行确认和修改。而由于这次的项目得到重视的程度更甚，我也了解到了很多手机小程序的开发中较为重要的小技巧。

比如在IOS设备上，页面的大小就有各种不同分辨率；而且系统还存在某些自认为“智能”的行为，比如如果焦点选中某个输入框，而输入框的文字大小小于16px，那么不管页面的meta信息里是否设置user-scalable为no，页面仍然还是会产生缩放。

同时，在电脑的浏览器上模拟手机端的屏幕大小看到的效果，换到手机上不一定仍然成立。就此问题，我询问了周围的同事，他们告诉我可以利用开发时的机器共享Wifi，并将开发的程序运行在本机的IP下，这样就可以使用自己的移动设备查看开发中的界面效果了。利用这个方法，又修复了与电脑浏览器显示效果不同的相关问题。

## 21

11月15

学习内容：利用Redis实现“附近的人”功能的细节

在之前的学习过程中了解到Redis Geo模块包含了以下6个命令：

GEOADD: 将给定的位置对象（纬度、经度、名字）添加到指定的key;
GEOPOS: 从key里面返回所有给定位置对象的位置（经度和纬度）;
GEODIST: 返回两个给定位置之间的距离;
GEOHASH: 返回一个或多个位置对象的Geohash表示;
GEORADIUS: 以给定的经纬度为中心，返回目标集合中与中心的距离不超过给定最大距离的所有位置对象;
GEORADIUSBYMEMBER: 以给定的位置对象为中心，返回与其距离不超过给定最大距离的所有位置对象。

简单总结下其中较为重要的GEORADIUS命令是怎么利用geohash获取目标位置对象的：
1、参数提取和校验；
2、利用中心点和输入半径计算待查区域范围。这个范围参数包括满足条件的最高的geohash网格等级(精度) 以及 对应的能够覆盖目标区域的九宫格位置；（后续会有详细说明）
3、对九宫格进行遍历，根据每个geohash网格的范围框选出位置对象。进一步找出与中心点距离小于输入半径的对象，进行返回。

## 22

11月18

工作内容：学习正则表达式的相关知识

学习Django框架之余，由于近期仍然没有布置给我的任务，于是在先前的学习基础上寻找自己的知识盲区，于是确定下来了正则表达式这个作为校验规则或是其他用途时，经常会使用的内容作为我近日的任务。

在进行之前的学习任务时，通常我都会在看过功能说明之后使用示例代码进行简单地实践以确认自己是否掌握，这次进行正则表达式的学习时也是如此。首先参照着网络上关于正则表达式的语法规则进行记忆，然后寻找某些规则对应的联系题目进行匹配的尝试。如此反复就能够记住某条匹配规则，并在初学者的角度掌握它的使用方法。

在其中举例的话，我认为正则中的环视十分简洁好用。它作用相当于对所在位置加了一个附加条件，只有满足这个条件，环视子表达式才能匹配成功。且它只进行子表达式的匹配，其匹配结果不占有字符，也不保存到最终的匹配结果，是零宽度的。

## 23

> 10月23 马尔可夫随机场在摸鱼

11月22

工作内容：学习一些流行技术

由于上一个项目刚刚结束，于是在项目的空窗期之内，我找到了流行的机器视觉领域的马尔科夫随机场的相关介绍内容，以下对学习内容进行简单记录。

 在机器视觉领域，一个图像分析问题通常被定义为建模问题，因此建模的过程就是定义目标函数的过程，模型求解的过程就是利用各种优化工具来解目标函数的过程。之所以需要使用各种优化工具，是因为在处理过程中存在着各种各样的不确定性，使用优化工具可以客观真实的模拟模型解。
 MRF适用于图像分析的原因是它提供了一个方便且一致的建模方法。马尔科夫随机场的概念和思想，来源于随机过程中的马尔科夫过程。不过马尔科夫过程更多的是针对时间序列建模而MRF更多的针对的是空间关系建模。在利用MRF建模解决实际问题时，往往将使用多个MRF。比如在边缘检测时，一般会用到两个MRF模型，一个对像素建模，一个对边缘建模。

## 24

11月25

学习内容：关于前端网页发布时可能遇到的url的填写情况

在nginx中配置proxy_pass代理转发时，如果在proxy_pass后面的url加/，表示绝对根路径；如果没有/，表示相对路径，把匹配的路径部分也给代理走。研究这个问题主要是因为之前进行开发时，遇到过代理的过程中填写和不填写斜杠会影响代理的成功与否，填写错误的话就无法直接在访问ip地址时直接导航到需要访问的地址。

简单地总结几种代理地址的写法如下：假设下面四种情况分别用 http://192.168.1.1/proxy/test.html 进行访问。

第一种情况，location /proxy/ 的 proxy_pass写成http://127.0.0.1/，代理的结果时http://127.0.0.1/test.html

第二种情况，代理proxy_pass比第一种最后少一个斜杠/，代理的地址是http://127.0.0.1/proxy/test.html

第三种情况，代理proxy_pass http://127.0.0.1/aaa/，代理的地址是http://127.0.0.1/aaa/test.html

第四种，代理proxy_pass比第三种少最后一个斜杠/，代理的地址是http://127.0.0.1/aaatest.html

总而言之就是上面的四种情况，在进行部署时需要熟知其中的不同写法，根据自己的需要进行代理情况的选择。

## 25

11月29

工作任务：了解技术栈Element-UI的相关介绍

element-ui 组件库之所以受欢迎，除了组件丰富，文档友好之外，还得益于它的精美的设计。由于它对各个组件具有规范化的字体、颜色、边框样式，用它做出来的设计会具有很好的整体感。这样的思想最早能在Bootstrap里见到。

组件库在色彩，字体，边框，图标方面提供了一系列常用的样式。

色彩包括主色、以及辅助色。这些颜色在实际实现的时候都是用到了SASS内置的Mix函数实现的。

字体

见[这里](https://juejin.im/post/5d9ebaddf265da5b591b64b3)