# 实习笔记

## 3

9月9日

工作内容：Vue2.0的学习

本周的任务安排包括学习Vuejs的相关知识，细化可以分成路由守护、Vuex的页面间状态交换机，API的调用的熟悉等。

在理论阶段，我了解到了调用API的工具axios，并在实现登出功能时使用了所需要的API。实践阶段，我通过使用catch语句解决了由于路由调用错误而出现的NaviagationDuplication问题，这个解决方法是来自github上的别人提出的关于路由钩子的相关问题。

不仅如此，由于包含登录功能的前端系统通常会用到存储的Cookies，需要通过vuex辅助Cookies实现不同路径下页面内的带权限限制的访问功能。基于此点了解了关于Expires等属性相关的赋值以及意义。

由于需要模仿实现的系统中包含多种功能与子功能的页面，后记还挑选了其中一部分具有代表性的内容进行着重地练习。主要包括登录，一览，人员情况分类等等。其中给我留下较深印象的是尝试进行Account总体数据的显示页面的实现过程。

## 4

9月13日

工作内容：Vue2.0的学习

对本周的工作内容进行总结。在上一周的练习项目的基础上，继续运用了vue-validator，组件之间数据传递的其他方法，element-ui的CSS框架，对原型对象挂载全局函数等技术点。

接下来对各个技术点在实践时遇到的问题

在使用vue-validator进行表单提交项时，需要使用Vue原型的$refs属性对需要检查的form进行注册（也叫挂载），才能够使用validator的检测库来检验其数据是否符合编程者规定的正则约束。

在使用Vue框架进行前端的实现时，组件之间的数据传递可以简单分为以下几种方式：1. 使用路由的变量进行数据传递。这种形式传递的数据会直接显示在路由里。 2. 使用挂载在Vue原型上的vuex库，他能够以规定的流程接收某个组件内的数据并储存，等待其他页面对其中存储的数据进行访问。 3. 将单独的一个Vue作为Bus（总线）挂载在原型Vue上，使原型Vue下的所有组件页面都能够对该Bus内的数据读写。

## 5

9月16日

工作内容：微信小程序

本周开始了手机上的小程序的设计，主要学习到的知识点如下：

element-ui，主要了解了TimePicker等各种时间日期选择器的用法，生成几个固定的时间点，以便用户快速选择。

在Vue原型上挂载对JS的Date对象原型添加的该应用下的页面全局都可使用的函数，主要利用了export default install(Vue, options)这种形式实现。

不仅如此，还遇到了一些页面上的问题。比如，不知道是因为框架还是什么其他的原因，点击单个item没办法直接切换整个元素的选中。

除此之外，还对设计的该小程序进行了界面和功能点上的优化。心得如下：

CSS方面：使用的图片如果是本地文件，而需要用到vue的动态绑定功能来动态地显示图片，就需要在:src的基础上，将本地图片的地址用require进行引用。在单选框的样式需要更改的情况下，需要用background-size: cover，并使用:class实现选择按钮的样式切换。

由于暂时不知道部署后的完整URL是什么，所以暂时不知道的是如何获取taxCode的地址。

## 6

9月20

工作内容：微信小程序

在前日的基础上，继续对JS进行了优化，包括但不限于以下内容：

利用先前学习的将函数挂载在vue原型上的方法，将每个组件中包含的时间格式的函数放到了全局函数的文件里（exports.install = ...）

顺应需求的变化，在成功完成事务后直接跳转至新页面（window.location.href = url）

就前一篇记录中提到的不知道完整的部署url问题，已经得到解决。最后的解决方法是通过url来获取查询页面公司的taxCode的。（let e = /(?=taxCode=)(\d+), let taxCode = e.exec(url)[1]）

至于CSS的优化，更改了一些图片、单选框的样式，颜色的统一问题，调整了消息框的样式。如果遇到CSS的优先顺序的问题，可以将需要覆盖其他样式的语句写上!important，但在项目的规模较大时，最好避免使用这条语句，以免造成进一步的覆盖。

等到项目接近完成时，遇到了静态图片以及element-ui的相关icon打包失效的问题。最后查询了网页，发现是webpack的打包参数配置中，需要将有效的路径调整为相对路径的'./'，再添加一行 publicPath: '../../'或者是在webpack.base.conf.js中添加resolve(path.join(__dirname, '..', dir))的函数。

## 7

9月23

工作内容：Vue2.0学习的收尾

由于先前的小程序项目用到了根据用户滑动屏幕的动作进行列表数据的加载的功能，而且滑动事件发生的时候，页面的当前滑动高度scrollHeight通常会频繁地变化，所以需要用到防抖和节流的相关处理方法。其中，防抖指触发事件后在规定时间内回调函数只能执行一次，如果在规定时间内又触发了该事件，则会重新开始算规定时间；而节流是指通过定时器将回调函数进行延时。如果在规定时间内继续回调，发现存在之前的定时器，则将该定时器清除，并重新设置定时器。这里有个细节，就是后面所有的回调函数都要能访问到之前设置的定时器，这时就需要用到闭包。为了全局调用的方便，还将它加入到了Vue的全局函数库中。

除此之外，值得一提的是使用了LESS语言编写Vue组件的内部样式。这种预处理语言能够以变量，函数的概念来编写CSS样式，使存在包含关系的DOM节点的样式属性能够更加方便地只在作用域内生效。

## 8

9月27

工作内容：Django的学习

在通过前辈写的练习项目以及微信小程序的锻炼下，初步地学习并实践了使用Vue2.0进行前端开发的过程，见识了一些应用过程中可能出现的问题以及了解掌握了对应的解决方法。

但Vue2.0毕竟是开始实习之前就已经掌握了部分应用方法的一种技术，在此基础上，还是希望能够充分利用前来公司实习的时间，不仅能够将所学运用到实践中，也了解与前端相关的更多流行技术，于是我选择了接下来进行Python语言下的Django网页开发框架的学习。

选择Django的一方面是因为我对Python语言比较熟悉，了解它的基础语法和一部分常用库函数；另一方面则是因为Python在目前的行业领域内的知名度和流行程度比较高，发展的空间也被大多数人看好，很多既有的算法开发也会考虑Python作为开发语言。于是在接下来的一段时间内，我会参考Django的官方网站上的示例应用开发教程，在同时结合经验与使用网络资源补充知识的方法下，开展对Django的使用方法的相关学习任务。

## 9

9月30

工作内容：完成Django在服务器端的应用方法

虽然Django也包含类似于Vue2.0的页面组件的视图内容，但比起Vue，Django的不同点在于一个网页应用的前端到后端都能够用它来完成，基于的就是它的业务层中的模型层、模板层。

由于网页一般需要基于表单，输入框来接受或是固定类型或是不固定类型（取决于使用的数据库是否是面向关系型的）的数据，并将它们储存于数据库之中，Django的模型层就是用来定义数据被存储到数据库列中所对应的类型的。主要通过Model Class来进行类型的定义，定义后通常还会使用Migration将由代码定义的数据库表“同步”到真正的数据库中。在这一层，也会用到QuerySets等方法进行数据的查询。

如果需要对数据库的数据进行处理，比较推荐的执行方法通常是建立一个模型实例管理对象，并在模型实例中创建调用模型对象中包含的方法。这样能够一定程度上对模型对象的管理进行自定义，而且能够保证原对象方法不受到个别程序开发需要的影响。

## 10

10月4 划掉 10月8

工作内容：Django框架在网页前端的应用方法

同Vue只能作为前端应用开发的框架，在跨域这个行为方面来说不一样的是，Django的服务器程序可以和页面提供代码同时使用dispatcher将使用了某个指定的template的视图挂载到指定路由下，也就是说网页中看到的视图实际上是直接由服务器在接收到HTTP请求后传递过来的HTML数据，所以由于不存在域名/IP、端口方面的差别，会比需要借助axios等工具发送后端请求而言更加便捷。

而和Vue相同的则是作为更为丰富的视图样式的定义解决方法存在的Templates。此类模板通常通过get_template受到调用，接收一定格式的数据，并经过Django的渲染函数将数据渲染至模板内规定的数据表示位置。

此外，在建立网页应用的显示部分的内容时，发现先前进行Model的数据查询方法的定义的一点差异：Model.objects.get()以及Model.object.filter()之间存在的区别是返回数据的类型，前者是question，后者则是questionSet。

## 11

10月11

工作内容：Vue3.0的预了解与公司组织的电影会

Vue3.0的核心机制是称为Function-based API。与2.0中的单页面内包含的函数等内容都是以对象包裹不同的是，核心的内容都将以函数的形式被提供。这一改动能够让原先的mixin模式带来的比如模板中的数据来源不清晰、命名空间重复等问题得到一定程度上的解决。

实现这一改动的原理是Vue3.0使用了Proxy来代替原先的Object.defineproperty来实现互动对象的数据响应问题。通过劫持get和set这两个大部分的数据类型都有的数据值修改和读取行为，能够将页面从原来的mixin模式下解放出来，最后达到减少原本额外的组件实例嵌套封装造成的额外开销的目的。

而早上进行了上述内容的学习之后，下午就随着同事们一起骑车前往了公司附近的影院准备去看《我和我的祖国》。由于我是实习生的缘故，并没有公司里大家都有的短袖工装，于是我就换上了同事姐姐临时发给我的短袖工装，在电影放映厅的外面和大家一起拿着国旗拍了照。这次与大家一起行动的集体活动还是很让人印象深刻的。

## 12

10月14

工作内容：了解使用Vue3.0实现v-model的方法

值得一提的是，在Vue3.0中， 已经不再支持 v-model 了，而使用 .sync 来代替，但是仍然能够利用 vue 的双向绑定实现 vue2.x 中的v-model功能。

Vue2.0中，框架的工作逻辑是首先获取模板的v-model属性，并获取绑定到的属性。此后，当数据发生变化时， 更新视图（这里会在trigger进行触发），当视图改变数据时修改数据。下面是数据变化响应对象的创建和视图更新的响应方法：

昨天知道了Proxy能够返回一个已经代理的对象，，那么只要对一个对象设置一个包含get和set动作的处理方法的代理，就能在这两个行为被触发时进行数据处理了。为了让包含多层嵌套的对象的内部数据修改都能够被捕捉到，也可以在处理方法里写一个按深度迭代的逻辑，这里不做赘述。

在模板编译的过程中，只要获取到某个元素标签中存在v-model属性，就对它添加一个watcher，内容是监听某个元素的改变事件，并返回上面的响应对象。

这样就能够做到在V3.0中继续使用v-model属性进行数据的监听了。

## 13

10月18

工作内容：Vue3.0 TS

在Vue2.0广泛的到应用的同时，开发组早在去年就开始了Vue3.0的筹备计划。在了解到3.0放出了先览内容的reactive对象之后，我通过搜索引擎了解到了在这次版本更新中作为基地的TypeScript的作用。它能够在JavaScript的语法基础上，为函数或者变量提供类型方面的约束或是进行接口扩展的一系列操作。

我还了解到，在此基础上， 组件 API 设计所面对的核心问题之一就是如何组织逻辑，以及如何在多个组件之间抽取和复用逻辑。  Function-based API 受 React Hooks 的启发，提供了一个全新的逻辑复用方案，且不存在上述问题。  使用基于函数的 API，开发者将与组件相关联的代码抽取到一个 "composition function" 中，也就是做到了将逻辑进行封装， 并将需要暴露给组件的状态以响应式的数据源的方式返回出来 。这样写出的组件既能够清晰地知道模板中的属性的来源（从函数返回），返回值也可以被任意重命名。

## 14

10月21

工作内容：学习LaTex的相关知识

除了项目方面，个人觉得也应该熟悉各种其他可能会用到的技术。举例而言，LaTex语言是一种建立在TeX上的免费文档处理系统，后者是一种用于排版开发的语言，但是在稍作了解后发现比较难以学习与使用，而且在进行文档撰写时也用不到其中很多的内容，于是选择学习扩展了TeX中的文档创建相关内容的LaTeX。

根据不同的电脑操作系统，可能会有已经安装好了TeX的电脑，但Windows下首先需要完成的工作就是安装。在此之前，我了解到MD语言的编译器能够支持LaTeX的语法显示，于是找到了在线的MD编辑器作为学习LaTeX的平台。

就结果而言，平常用到的比较多的一般是普通的数学符号，简单的单行公式的上下标记。如果涉及到需要用到复数行的公式的话，就要学习有关多行公式的内容了。有关内容准备等到日后需要用的时候再进行查阅。

## 15

10月25

工作内容：了解Vue3.0的性能提高原理和新性能的利弊

前段时间已经知道，在Vue3.0中用到Proxy代替原先的数据行为跟踪。在此次更新中， 整个数据监听系统都进行了重构，由es5的Object.defineProperty改为了es6的proxy 。Vue的创始人说这个新的数据监听系统带来了初始化速度加倍同时内存占用减半的效果，主要因为以前的Vue2.0使用的Object.defineProperty存在两点问题：需要遍历所有的属性，如果对象的data或computed或props中的数据项内容多，遍历起来的速度就会变慢，用于监听的内存开销也会变大。

而在JS的语法更新到ES6之后，在Vue3.0利用了Proxy之后，不仅解决了上面所说的内存问题，新添加的数据类型Set、 WeakSet、Map、WeakMap的变化也能够受到监听、同时可以监听Class、属性的新建和删除以及数组元素的增加和删除。而Vue3.0唯一的缺点就是在检测到如果是使用IE的情况下会自动降级为Object.defineProperty的数据监听系统，享受不到速度加倍，内存减半的体验。

## 16

10月28

学习内容：利用Redis实现“附近的人”功能

从网络上的一篇文章上了解到针对“附近的人”这一位置服务领域的应用场景，常见的可使用PG、MySQL和MongoDB等多种DB的空间索引进行实现。而Redis另辟蹊径，结合其有序队列zset以及geohash编码，实现了空间搜索功能，且拥有极高的运行效率。

要提供完整的“附近的人”服务，最基本的是要实现“增”、“删”、“查”的功能。自Redis 3.2开始，Redis基于geohash和有序集合提供了地理位置相关功能。 Redis Geo模块包含了以查为核心的六个命令，可以很快地返回给定位置对象为中心的不超过给定最大距离的所有位置对象。

具体实现通过组合使用GEOADD和GEORADIUS可实现“附近的人”中“增”和“查”的基本功能。直接使用GEORADIUSBYMEMBER命令实现微信中“附近的人”功能。其中“给定的位置对象”即为用户本人，搜索的对象为其他用户。不过本质上，GEORADIUSBYMEMBER = GEOPOS + GEORADIUS，即先查找用户位置再通过该位置搜索附近满足位置相互距离条件的其他用户对象。

## 17

11月1

工作内容：票据查询微信小程序

上一次的票据小程序交给我之前，没有让我参加开发组的会议，且没有UI设计师参与，而是组长直接交给我经由原型设计的界面稿。而在这次，组长让我也参与了和产品、UI设计以及测试的人们一起参加的协作会议。

在会议上，原型首先给大家展示了总结了客户需求之后发布的第一期原型稿。在演示期间。我们都认真听取了原型的设计内容并作了一定笔记。演示过后，大家都就刚才听到的内容提出自己的疑问，部分地方也就一些存疑内容进行了协商和妥协。最后，其中的一部分原型设计内容得到了大家都觉得比较合理的修改，会议就结束了。

在这次会议里，我体会到了项目组人员进行沟通的必要性。因为只有在大家经过讨论，修改了原型的不合理之处后，才有可能将一些后期难以修改的错误在早期就改正过来。不仅如此，这样的会议也有助于让所有人对最后的产品有一个全景图，能够以全局出发进行个人的设计。

## 18

11月4

工作内容：进行微信小程序的开发

虽然在工作刚刚开始的时候就已经参与了会议，并解决了一部分原型设计中隐含的问题，但是在这之后，仍然还是遇到了需求与实际开发内容存在较大误差的情况。

由于实际作为前端开发，能够参照的文档就是原型文档、UI的设计文档以及后端的API说明文档，所以如果是这两个文档之中没有详细说明的需求，或是某个功能的实现细节，作为前端的开发只能在个人的能力或者理解范围之内进行优化和调整。如果以后还会进行开发工作，个人感觉比较必要的是拿到一份客户需求的详细说明文档，这样就能够在兼顾多方设计的情况下给出一个较好的前端解决方案。

最后，虽然就个人测试结果，修改了的内容也有很多，但是还是需要将项目交给测试的同事，等待他们的后续反馈，再对目前开发的项目进行修改。

## 19

11月8

工作内容：微信小程序的优化

和之前的项目相比，此次的项目确实在人员组织上十分正规。不仅有之前所说的UI设计参与，而且测试的同事也会在禅道这样的项目管理页面上进行错误的提交和反馈。

以前有人说JavaScript是一种比较混乱的语言，虽然随着网页的普及，语言本身已经得到很大程度的优化了，但很多时候仍然会发生让开发者觉得匪夷所思的问题，所以JS这一部分才会被认为是很多公司面试里的重难点吧。这次进行开发的时候，测试也提出了一些类似的问题。

除此之外，由于是微信小程序，需要在各种不同的型号的手机上进行测试，确保各种平台的使用用户的体验是一致的。所以在页面上的调整内容大部分都是与平台不兼容相关的。开发时的流程就是写页面→测试→根据设备调整页面兼容→根据UI设计稿调整总体效果。

## 20

11月11

工作内容：微信小程序的收尾

在项目交付的前日，各个岗位的大家仍然在就自己的工作范围内的任务进行确认和修改。而由于这次的项目得到重视的程度更甚，我也了解到了很多手机小程序的开发中较为重要的小技巧。

比如在IOS设备上，页面的大小就有各种不同分辨率；而且系统还存在某些自认为“智能”的行为，比如如果焦点选中某个输入框，而输入框的文字大小小于16px，那么不管页面的meta信息里是否设置user-scalable为no，页面仍然还是会产生缩放。

同时，在电脑的浏览器上模拟手机端的屏幕大小看到的效果，换到手机上不一定仍然成立。就此问题，我询问了周围的同事，他们告诉我可以利用开发时的机器共享Wifi，并将开发的程序运行在本机的IP下，这样就可以使用自己的移动设备查看开发中的界面效果了。利用这个方法，又修复了与电脑浏览器显示效果不同的相关问题。

## 21

11月15

学习内容：利用Redis实现“附近的人”功能的细节

在之前的学习过程中了解到Redis Geo模块包含了以下6个命令：

GEOADD: 将给定的位置对象（纬度、经度、名字）添加到指定的key;
GEOPOS: 从key里面返回所有给定位置对象的位置（经度和纬度）;
GEODIST: 返回两个给定位置之间的距离;
GEOHASH: 返回一个或多个位置对象的Geohash表示;
GEORADIUS: 以给定的经纬度为中心，返回目标集合中与中心的距离不超过给定最大距离的所有位置对象;
GEORADIUSBYMEMBER: 以给定的位置对象为中心，返回与其距离不超过给定最大距离的所有位置对象。

简单总结下其中较为重要的GEORADIUS命令是怎么利用geohash获取目标位置对象的：
1、参数提取和校验；
2、利用中心点和输入半径计算待查区域范围。这个范围参数包括满足条件的最高的geohash网格等级(精度) 以及 对应的能够覆盖目标区域的九宫格位置；（后续会有详细说明）
3、对九宫格进行遍历，根据每个geohash网格的范围框选出位置对象。进一步找出与中心点距离小于输入半径的对象，进行返回。

## 22

11月19

工作内容：学习正则表达式的相关知识

学习Django框架之余，由于近期仍然没有布置给我的任务，于是在先前的学习基础上寻找自己的知识盲区，于是确定下来了正则表达式这个作为校验规则或是其他用途时，经常会使用的内容作为我近日的任务。

在进行之前的学习任务时，通常我都会在看过功能说明之后使用示例代码进行简单地实践以确认自己是否掌握，这次进行正则表达式的学习时也是如此。首先参照着网络上关于正则表达式的语法规则进行记忆，然后寻找某些规则对应的联系题目进行匹配的尝试。如此反复就能够记住某条匹配规则，并在初学者的角度掌握它的使用方法。

在其中举例的话，我认为正则中的环视十分简洁好用。它作用相当于对所在位置加了一个附加条件，只有满足这个条件，环视子表达式才能匹配成功。且它只进行子表达式的匹配，其匹配结果不占有字符，也不保存到最终的匹配结果，是零宽度的。

## 23

11月22

工作内容：学习一些流行技术

由于上一个项目刚刚结束，于是在项目的空窗期之内，我找到了流行的机器视觉领域的马尔科夫随机场的相关介绍内容，以下对学习内容进行简单记录。

 在机器视觉领域，一个图像分析问题通常被定义为建模问题，因此建模的过程就是定义目标函数的过程，模型求解的过程就是利用各种优化工具来解目标函数的过程。之所以需要使用各种优化工具，是因为在处理过程中存在着各种各样的不确定性，使用优化工具可以客观真实的模拟模型解。
 MRF适用于图像分析的原因是它提供了一个方便且一致的建模方法。马尔科夫随机场的概念和思想，来源于随机过程中的马尔科夫过程。不过马尔科夫过程更多的是针对时间序列建模而MRF更多的针对的是空间关系建模。在利用MRF建模解决实际问题时，往往将使用多个MRF。比如在边缘检测时，一般会用到两个MRF模型，一个对像素建模，一个对边缘建模。

## 24

11月26

学习内容：关于前端网页发布时可能遇到的url的填写情况

在nginx中配置proxy_pass代理转发时，如果在proxy_pass后面的url加/，表示绝对根路径；如果没有/，表示相对路径，把匹配的路径部分也给代理走。研究这个问题主要是因为之前进行开发时，遇到过代理的过程中填写和不填写斜杠会影响代理的成功与否，填写错误的话就无法直接在访问ip地址时直接导航到需要访问的地址。

简单地总结几种代理地址的写法如下：假设下面四种情况分别用 http://192.168.1.1/proxy/test.html 进行访问。

第一种情况，location /proxy/ 的 proxy_pass写成http://127.0.0.1/，代理的结果时http://127.0.0.1/test.html

第二种情况，代理proxy_pass比第一种最后少一个斜杠/，代理的地址是http://127.0.0.1/proxy/test.html

第三种情况，代理proxy_pass http://127.0.0.1/aaa/，代理的地址是http://127.0.0.1/aaa/test.html

第四种，代理proxy_pass比第三种少最后一个斜杠/，代理的地址是http://127.0.0.1/aaatest.html

总而言之就是上面的四种情况，在进行部署时需要熟知其中的不同写法，根据自己的需要进行代理情况的选择。

## 25

11月29

工作任务：了解技术栈Element-UI的相关介绍

element-ui 组件库之所以受欢迎，除了组件丰富，文档友好之外，还得益于它的精美的设计。由于它对各个组件具有规范化的字体、颜色、边框样式，用它做出来的设计会具有很好的整体感。这样的思想最早能在Bootstrap里见到。

组件库在色彩，字体，边框，图标方面提供了一系列常用的样式。

色彩包括主色、以及辅助色。这些颜色在实际实现的时候都是用到了SASS内置的Mix函数实现的。

字体是用font-family 指定一个字体列表，属性值用逗号隔开，这样浏览器就会选择列表中第一个该计算机上有安装的字体。对于不同组件中的文字，默认则存在六种不同的大小。

Element-UI也对边框进行了统一的规范，使其在按钮、卡片、弹窗中的表现是相同的。

由于本人第一次见到这样的设计规范化框架是在使用Bootstrap，一开始觉得它像Bootstrap的原因也是因为它同样提供了常用的图标集合，这些图标可以直接通过设置类名为el-icon-[iconName]来使用。

## 26

12月2

工作内容：微信H5端平台开发准备

上周周末收到了新的工作安排，是关于新的微信H5端的开发的项目，同期也收到了产品和组长开会后决定的产品原型图，与此同时也告诉我此次的项目最好在12月20日之前能够完成，此为交付日期。

在此时我只是拿到了原型文档，真正的前端开发仍然需要等到此次平台的设计稿出来才能开始，所以近期的任务仍然是观看原型文档，根据原型文档首先对各个界面的DOM结构进行初步的设计，以及理清系统需要实现的功能和与其相关的逻辑需要如何实现。

除此之外，继续根据页面的预期效果进行了整个平台的页面关系的设计。其中包括标准的登录页面，以及登录成功后所有页面共享的顶端导航栏和内容的布局安排。由于后端的接口逻辑和文档仍然还在撰写中，目前暂时只能利用预想的数据结构和测试数据进行部分页面功能的实现。

## 27

12月5

工作内容：微信H5端平台页面实现

在前几天为正式的页面设计打下框架基础之后，今天拿到了页面的设计稿。和上次一样，都是通过蓝湖的网页端进行设计稿的查阅，并以此为依据进行前端页面的实现。

与上次相同的，通过这个设计观看界面能够很方便地第一时间查看到设计对设计稿进行的修改，页面的添加等等方面。对于前端的工作范围而言，这样的网页原型稿还会包含页面相关的CSS代码，在一些基础配置上可以帮助前端开发人员节省时间。如果是不方便选中的元素则可以用页面内置的取色器来获得颜色的十六进制值用于编写CSS。

与上次不同的是，此次的界面设计人员考虑到各个方面的因素，对我表示在设计方面只需要保持一致即可，一些细节方面尽量做到复现，但由于设备引起的和设计稿不一致的地方可以不用特别纠结。

## 28

12月10

工作内容：微信H5平台的功能逻辑实现

由于已经进行过与此次任务比较类似的平台开发，而且同样都是微信H5的平台，就算距离交付时间仍然还有充裕的时间，但是页面的框架都差不多搭建好了。

同样是比较熟悉的vue作为前端框架，element-ui作为页面设计标准的组件，也利用axios进行后端服务端口的调用。

不同的是进行登录的时候，新的需求内容是登录过程中需要进行加密登录。进行加密登录就需要将登录过程分成两个步骤。第一步是访问提供加密密码的公钥，第二部是将使用公钥加密后的字符串作为参数发给服务器等待校验。

由于每次申请公钥获得的公钥都不一样，就无法使用预存加密密钥的方法检验加密结果是否正确。在不是很清楚此方面算法的使用方法时，我请教了组里一位在前些时候使用过前端加密库的前辈，从她那里了解了加密的正规使用方法。

## 29

12月13

工作内容：微信H5平台的接口调用逻辑整理

近期继续跟进之前就开始开发的平台，由于部分接口在后端那里仍然还在修改阶段，所以前端也需要联系后端进行同步的调整与开发。

有时在前端返回值不对是由于axios进行后端的API调用时的行为与ajax不太一样，而后端中的一人正是用的ajax进行接口的测试调用，另一人则是用的postman，所以就算文档上写的调用方法相同，实际在调用时又会因为后端代码风格不同（主要是参数接受定义方法不同）而导致前端进行调用时需要使用不同的方法。

最后，可以进行几种不同的调用方法的归纳：get方法可以选择将参数直接拼接在请求URL后方，或者是注明请求的params为数据对象，且其content-type为application/json。如果是post方法，可以将数据用JSON.stringify()或者qs.stringify转为子字符串数据传输，content-type为application/x-www-form-urlencoded即可。

## 30

12月16

工作内容：微信H5平台的功能逻辑确认

随着开发的进展，大部分的功能都有了雏形或者大部分完成。在开发过程总也能够对自己掌握的前端知识进行查漏补缺是这段时间以来的很大收获。

除了从未实现过的新功能中学习解决方法以外，也存在过去已经实现过的功能在此次使用时需要用到新的解决方法的时候。比如光是通过接收后端传来的图片，就可以有首先在后端生成图片的二进制编码字符串内容，再通过Vue的动态绑定src进行图片的显示；或者如果接口返回的直接就是图片数据（在preview里能看到图片），那么只需要在动态绑定的src里填写api的地址即可，框架会自动对src内的api地址发送请求并加载返回的图片数据。

## 31

12月20

工作内容：微信H5平台的功能逻辑修改

虽然需求在较早时期就已经打成了共识，但是在验收之后，后端和前端仍然存在一定程度上需要修改的地方。

比如由于文档书写不当的位置，在文档进行修改之后，前端也需要进行相应的更改。其中留下较深印象的是关于业务内两个字段名称比较相像的参数类型弄错了，于是传给后端的数据最后被做了错误的计算。

实话说，这次修改还算比较让人措手不及，造成这样的局面主要还是因为我的经验不足。一开始后端说起这件事情的时候，由于我不是很了解业务的内容，我以为只需要将两个参数名称改过来就好了。过了一段时间之后，测试的人和我说我的计算仍然使用的是不正确的数据，我才真正了解了业务的流程，要解决这个问题不是单单将变量名字改过来就好了。最后在询问了组长业务流程之后才完成了系统的修改。

## 32

12月24

工作内容：微信H5平台的功能逻辑丰富

在此后的开发工作中根据平台的反馈情况逐渐了解到，该平台判断用户是否登陆，Token是否有效等逻辑，实际是在客户提交查询请求之后进行的。也就是说用户端并不进行登录Token的检验，这些都是交给后端处理的。此前虽然也做过登录情况的校验，但是基本都是在本地进行的。

除此之外，在文档中也看到了关于登录状态检验相对应的更新。文档说明，在登录状态过期的时候，将会返回相应的状态代码以及状态说明，于是为了让平台的使用体验更加良好，就为这类状态代码添加了提示逻辑以及后续处理。

此次过后需要吸取教训的是，在进行代码的修改之前，一定要想明白修改过后会不会反而降低用户体验。这是因为这次修改时，不小心改了一个不应修改的位置，使得不应该进行提示的地方也产生了提示文字。

## 33

12月26

工作内容：微信H5平台提出错误的修改

虽然平台在昨天就已经拿去交付演示了，但是我由于需要参加学校答辩的缘故，昨天请了一天假。就在这天的上午，测试组突然在通讯软件上通知我说有几项需要修改的内容。

首先是由于对系统业务的不明晰，前端和后端都不了解业务需要的所有数据项目；在详细数据页面里，没有对所有数据进行统计，导致显示的不正确；其次，页面的首页标题始终没有确定下来，这个是从需求阶段就已经遗留下来的问题；最后，也是本人需要负责任的问题点，由于没有考虑到过长的数据可能对响应式界面元素产生页面的挤压和变形，在遇到了这样的较为特定类型的数据时，这个问题就暴露了出来。

由于我昨天不在公司，其中的几个问题点组长已经帮我代劳了，在这里对他感到非常抱歉。在工作中能够遇到这样的前辈实在是我的荣幸。在今天来到公司之后，我也赶忙修复了剩下的问题。

## 34

12月30

工作内容：微信H5平台功能添加与更新

本周来到公司就参加了根据客户补充需求进行的后续开发会议。主要是针对上周的演示过程时，客户提出的反馈意见对现行系统进行修改。

对手机端程序提出的修正项一部分是包括界面的，而需求的变更点主要需要和后端配合。但是由于更改内容和先前业务处理流程的重合率比较高的缘故，实际需要修改的内容并不涉及大范围的改动，这一点可能也是让人欣慰的一点。

除此之外，为了让我负责的H5端与其他人负责的网页端功能相近，此次更新还增加了新的功能：通过后端提供的接口返回提醒文字内容。这方面的逻辑实际上是后端负责进行，我就不过多进行描述了。

此次改动让我了解到了一个多平台的产品在给客户演示之后可能会进行的一系列后续开发与维护，以及以往负责某些部分功能的人员可能会因为获得新的工作安排而不再继续跟进此项目等。

## 35

1月2日

工作内容：安排工作事务的交接

本周末为止，实习的工作就要告一段落了。从今天开始，最后一个项目中我负责的部分也进入了尾声。在离职之前，由于需要向学校递交公司方对个人实习的评价表内容，我就经由部门管理人的介绍，到我办理入职手续的楼上进行了离职手续的办理。

在办理的过程中，根据各项的需求前往不同的办公地点完成财务、保管物的交接这一点来说，让我体会到了一个公司需要按流程正常运转，需要各个部门相互配合。而由于我办公内容的限制，我对其他部门的人际关系并不是十分熟悉，所以还是在人事的指导下完成了各项事务的清算。

至于项目的交接，上传到了公司的Git管理仓库后，我与邻位的同事告知了这一点后就算告一段落了。由于大家使用的技术虽然都是Vue，但是框架模板似乎存在不同之处，为了其他人接手项目也能了解项目的构成，不可缺少的当然是附上注释。